[{"doc":"This page has not yet sprouted","title":"This page has not yet sprouted","hpath":"403","content":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","url":"https://r-neal-kelly.github.io/nkr/notes\\403.html","relUrl":"notes\\403.html"},{"doc":"nkr","title":"nkr","hpath":"root","content":"\n![[namespaces]]\n\n![[types]]\n","url":"https://r-neal-kelly.github.io/nkr","relUrl":"/"},{"doc":"Types","title":"Types","hpath":"types","content":"\n- [[atomic_t|types.atomic_t]]\n","url":"https://r-neal-kelly.github.io/nkr/notes\\LXyriMscLd0LXXd8vvQdI.html","relUrl":"notes\\LXyriMscLd0LXXd8vvQdI.html"},{"doc":"atomic_t","title":"atomic_t","hpath":"types.atomic_t","content":"\nA template wrapper for platform-dependent atomic objects, including booleans, integers, and pointers. Each specialization can be treated as the underlying type itself in almost every circumstance. And unlike `std::atomic`, `nkr::atomic_t` is strictly reserved for objects that are truly atomic in nature on each platform, without exception. *(Windows x64 and x86 are currently the only implemented platforms.)*\n\n![[types.atomic_t.specializations]]\n","url":"https://r-neal-kelly.github.io/nkr/notes\\Ozr6six1T1XAbFlMzQ8jo.html","relUrl":"notes\\Ozr6six1T1XAbFlMzQ8jo.html"},{"doc":"Specializations","title":"Specializations","hpath":"types.atomic_t.specializations","content":"\n- [[integer_p|types.atomic_t.specializations.integer_p]]\n- [[bool_t|types.atomic_t.specializations.bool_t]]\n- [[value_p*|types.atomic_t.specializations.value_p_pointer]]\n- [[void_t*|types.atomic_t.specializations.void_t_pointer]]\n","url":"https://r-neal-kelly.github.io/nkr/notes\\g1n6RFXl5B4XeScodHzeb.html","relUrl":"notes\\g1n6RFXl5B4XeScodHzeb.html"},{"doc":"void_t*","title":"void_t*","hpath":"types.atomic_t.specializations.void_t_pointer","content":"\nThis should be available on every platform. This is a distinct template specialization because it cannot offer the full functionality of `value_p*`, but it is otherwise exactly the same.\n","url":"https://r-neal-kelly.github.io/nkr/notes\\AhKLG2Ho2KALthIzcZSDo.html","relUrl":"notes\\AhKLG2Ho2KALthIzcZSDo.html"},{"doc":"value_p*","title":"value_p*","hpath":"types.atomic_t.specializations.value_p_pointer","content":"\nThis should be available on every platform.\n","url":"https://r-neal-kelly.github.io/nkr/notes\\Re4Z13PSCgwMUqJnN1UPD.html","relUrl":"notes\\Re4Z13PSCgwMUqJnN1UPD.html"},{"doc":"integer_p","title":"integer_p","hpath":"types.atomic_t.specializations.integer_p","content":"\nThis is the default specialization of [[types.atomic_t]]. Depending on the platform, most signed and unsigned integers are available, and at a bare minimum the `word_t` should be available. This has the full suite of atomic methods, all Access, Assign, and Exchange calls.\n\n## Aliases\n\n- `value_t` is `integer_p`\n\n## Static Asserts\n\n- `value_t` must satisfy `std::is_integral`\n\n## Constructors\n\nIt is important to note that none of the constructors are atomic. This means that they must be initialized in a thread-safe manner.\n\n- default\n- `value_t`\n- copy\n- move\n- copy assignment\n- move assignment\n\n## Destructor\n\nAtomically sets its value to 0.\n\n## Methods\n\n- [[Access]]\n- [[Access_Add]]\n- [[Access_Subtract]]\n- [[Access_Or]]\n- [[Access_And]]\n- [[Access_Xor]]\n\n\n- [[Assign]]\n- [[Assign_Add]]\n- [[Assign_Subtract]]\n- [[Assign_Or]]\n- [[Assign_And]]\n- [[Assign_Xor]]\n\n\n- [[Exchange]]\n- [[Exchange_If_Equals]]\n- [[Exchange_Add]]\n- [[Exchange_Subtract]]\n- [[Exchange_Or]]\n- [[Exchange_And]]\n- [[Exchange_Xor]]\n\n## Casts\n\n- [[value_t]]\n\n## Operators\n\n- [[Invoke]]\n\n\n- [[Assign]]\n\n\n- [[Add]]\n- [[Subtract]]\n- [[Add_Assign]]\n- [[Subtract_Assign]]\n- [[Increment_Pre]]\n- [[Increment_Post]]\n- [[Decrement_Pre]]\n- [[Decrement_Post]]\n\n\n- [[Bitwise_Not]]\n- [[Bitwise_Or]]\n- [[Bitwise_And]]\n- [[Bitwise_Xor]]\n- [[Bitwise_Or_Assign]]\n- [[Bitwise_And_Assign]]\n- [[Bitwise_Xor_Assign]]\n","url":"https://r-neal-kelly.github.io/nkr/notes\\JrHaS8tsuvHUZaSSndWH1.html","relUrl":"notes\\JrHaS8tsuvHUZaSSndWH1.html"},{"doc":"bool_t","title":"bool_t","hpath":"types.atomic_t.specializations.bool_t","content":"\nThis should be available on every platform.\n","url":"https://r-neal-kelly.github.io/nkr/notes\\KtwKKcNGEFBprJ7DAFXo1.html","relUrl":"notes\\KtwKKcNGEFBprJ7DAFXo1.html"},{"doc":"Namespaces","title":"Namespaces","hpath":"namespaces","content":"\n- [[os|namespaces.os]]\n","url":"https://r-neal-kelly.github.io/nkr/notes\\gB8Q2aOw23OLW5jtv54G8.html","relUrl":"notes\\gB8Q2aOw23OLW5jtv54G8.html"},{"doc":"os","title":"os","hpath":"namespaces.os","content":"\nThe purpose of this namespace is to wrap all operating system functionality and data behind a rarely changing interface. The goal is to be able to work every platform into this mold behind the scenes, usually involving preprocessor switches.\n\nThe philosophy of `nkr` is to wrap every alien piece of code possible, with the exception of standard `C` and `C++` libraries that are in use.\n\nThe `nkr_test` suite is currently a little more lenient towards foreign code, but the library proper is to be treated with the utmost sanctity.\n\n![[namespaces.os.namespaces]]\n","url":"https://r-neal-kelly.github.io/nkr/notes\\rhrrH0bkCOyRjkGrK65Ie.html","relUrl":"notes\\rhrrH0bkCOyRjkGrK65Ie.html"},{"doc":"Namespaces","title":"Namespaces","hpath":"namespaces.os.namespaces","content":"\n- [[atomic|namespaces.os.namespaces.atomic]]\n","url":"https://r-neal-kelly.github.io/nkr/notes\\dlq4YiiQJza87DjWIehdp.html","relUrl":"notes\\dlq4YiiQJza87DjWIehdp.html"},{"doc":"atomic","title":"atomic","hpath":"namespaces.os.namespaces.atomic","content":"\nThis namespace houses all of the atomic functions that are made available to the library proper. Depending on the platform, some functionality may not be available, however every single function is truly atomic and doesn't try to emulate anything when the processor simply cannot execute the operation atomically.\n\n![[namespaces.os.namespaces.atomic.functions]]\n","url":"https://r-neal-kelly.github.io/nkr/notes\\gRBDUa7dFEA7mLPFTuQNC.html","relUrl":"notes\\gRBDUa7dFEA7mLPFTuQNC.html"},{"doc":"Functions","title":"Functions","hpath":"namespaces.os.namespaces.atomic.functions","content":"\n- [[Access|namespaces.os.namespaces.atomic.functions.access]]\n","url":"https://r-neal-kelly.github.io/nkr/notes\\BbJZTg5hwl7Va0gISBIpl.html","relUrl":"notes\\BbJZTg5hwl7Va0gISBIpl.html"},{"doc":"Access","title":"Access","hpath":"namespaces.os.namespaces.atomic.functions.access","content":"\n## Declaration\n```cpp\n    template <integral_tr atom_p>\n    inline atom_p   Access(const volatile atom_p& atom);\n    template <pointer_tr atom_p>\n    inline atom_p   Access(const volatile atom_p& atom);\n```\n\n## Description\nAtomically returns the value of `atom` without changing its value.\n","url":"https://r-neal-kelly.github.io/nkr/notes\\7EKPGsYEZRgZ5nVIkVnIl.html","relUrl":"notes\\7EKPGsYEZRgZ5nVIkVnIl.html"},{"doc":"Changelog","title":"Changelog","hpath":"root.changelog","content":"","url":"https://r-neal-kelly.github.io/nkr/notes\\changelog.html","relUrl":"notes\\changelog.html"}]
