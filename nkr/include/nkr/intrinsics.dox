/*
    Copyright 2021 r-neal-kelly
*/

#pragma once

/**
* @defgroup namespaces namespaces
*/

    /**
    * @class doc_nkr
    * @private
    * 
    * @brief
    *   With the exception of "nkr_" prefixed macros, all other nkr entities are defined in this namespace.
    */

/**
* @defgroup intrinsics intrinsics
*
* @brief
*   Types and macros that are available whenever you include any nkr header.
*
* @details
*   Intrinsic types are mostly helpful aliases of standard C++ types. The style of the library dictates that each type and class must have the `_t` postfix and so there are a few complementary redefinitions. However other intrinsics exist for efficiency, semantics, or both. Some help to clarify the intention of the code they appear in and some are platform dependent, but using them in the correct context can alleviate the need to use macro switches.
*/

    /**
    * @defgroup intrinsic_hints hints
    * @ingroup intrinsics
    *
    * @brief
    *   Platform dependent definitions used by macro switches.
    *
    * @details
    *   Currently Windows x64 and x86 are the only platforms that have definitions, but I'm planning on taking a look at implementing functionality for Linux. These documents are compiled with the Windows x64 branch active.
    *
    * @hideinitializer
    */

        /**
        * @class doc_nkr_nkr_IS_WINDOWS
        * @private
        */

        /**
        * @class doc_nkr_nkr_IS_LINUX
        * @private
        */

        /**
        * @class doc_nkr_nkr_IS_32_BIT
        * @private
        */

        /**
        * @class doc_nkr_nkr_IS_64_BIT
        * @private
        */

    /**
    * @defgroup intrinsics_primitives primitives
    * @ingroup intrinsics
    *
    * @brief
    *   Primitive types aliased for consistency.
    */

        /**
        * @class doc_nkr_void_t
        * @private
        */

        /**
        * @class doc_nkr_bool_t
        * @private
        */

    /**
    * @defgroup intrinsics_integers integers
    * @ingroup intrinsics
    *
    * @brief
    *   Convenient integer types.
    *
    * @todo
    *   Add an example showing why the _t comes in useful when using integers. Also explain the u and s.
    */

        /**
        * @class doc_nkr_u8_t
        * @private
        */

        /**
        * @class doc_nkr_u16_t
        * @private
        */

        /**
        * @class doc_nkr_u32_t
        * @private
        */

        /**
        * @class doc_nkr_u64_t
        * @private
        */

        /**
        * @class doc_nkr_s8_t
        * @private
        */

        /**
        * @class doc_nkr_s16_t
        * @private
        */

        /**
        * @class doc_nkr_s32_t
        * @private
        */

        /**
        * @class doc_nkr_s64_t
        * @private
        */

    /**
    * @defgroup _17e74a8d_e977_4d08_a090_f4bb1bcf7673 characters
    * @ingroup intrinsics
    *
    * @brief
    *   Convenient character types, which are essentially integers.
    */

        // c8_t
        /**
        * @class _a878a755_773f_49d9_93c2_6567797188f1
        * @private
        */

        // c16_t
        /**
        * @class _22b18aae_67b8_49e5_855c_eb4117780773
        * @private
        */

        // c32_t
        /**
        * @class _70d1ce0d_2bb5_4a6e_ba42_c6c5fdfa5cb7
        * @private
        */

    /**
    * @defgroup _d3bf5147_2b5f_4bd4_bf99_76cf5b9932af floating points
    * @ingroup intrinsics
    *
    * @brief
    *   Convenient floating point types.
    */

        // f32_t
        /**
        * @class _2ad13e3a_26a3_4526_b482_a1f643d2cb99
        * @private
        */

        // f64_t
        /**
        * @class _a5fce9b9_cb18_4f58_acaf_79d2386f6bae
        * @private
        */

    /**
    * @defgroup intrinsics_contextuals contextuals
    * @ingroup intrinsics
    *
    * @brief
    *   Efficient context based types.
    *
    * @details
    *   These types are most commonly used on the stack, making them transitory and often only cached in small numbers. Most of them equate to the size of nkr::word_t, which has the same size as the processor's natural word. This is important when it comes to execution efficiency because the processor has to spend more time reading a variable that does not equate to its word size. Others are necessarily different sizes depending on their context.
    */

        /**
        * @class doc_nkr_byte_t
        * @private
        * 
        * @brief
        *   The smallest natural type available.
        */

        /**
        * @class doc_nkr_word_t
        * @private
        *
        * @brief
        *   The largest natural type available, the processor's word.
        */

        /**
        * @class doc_nkr_size_t
        * @private
        *
        * @brief
        *   Used for byte counts exclusively.
        */

        /**
        * @class doc_nkr_count_t
        * @private
        *
        * @brief
        *   Used for unit counts of any arbitrary type.
        */

        /**
        * @class doc_nkr_index_t
        * @private
        *
        * @brief
        *   Used for unit indices of any arbitrary array of types.
        */

        /**
        * @class doc_nkr_address_t
        * @private
        *
        * @brief
        *   Used for literal pointer math.
        */

/**
* @defgroup _7752ee81_def2_4386_b164_bc31f29ce7b8 interfaces
* 
* @brief
*   The various structs, types, and concepts with the "_i" postfix.
*/

// Common Notes

/**
* @class _f66dddf5_07cc_4240_b2e2_39253f780892
* @private
* 
* @note
*   Inherits all constructors, the destructor, and all assignment operators in addition to all other members of the base class.
* 
* @par
*/

/**
* @class _e245fac0_078f_4cf6_852c_a42932c2ffff
* @private
* 
* @note
*   See @ref _16d56f49_95ba_456e_a026_706c054cb133 for why we use inheritance to define this specialization.
* 
* @par
*/
