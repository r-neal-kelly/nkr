/*
    Copyright 2021 r-neal-kelly
*/

// nkr::os
/**
* @class _ae5b9a84_c87b_4c0a_b714_4933761921d7
* @private
*
* @brief
*   Short for "Operating System", this contains several wrappers for otherwise platform specific functionality.
*/

    // nkr::os::atomic
    /**
    * @class _a6ff4022_7389_4e35_b146_066ce313290e
    * @private
    *
    * @brief
    *   Functions that provide atomic access, assignment, and exchange of variables.
    * 
    * @details
    *   These functions can be used in a threaded environment to safely read and write to various integers, booleans, and pointers. They are far more resource friendly than locks and should be used in their place as frequently as possible.
    * 
    *   There are three primary sets of these functions, each differing in whether they write to the atomic or simply read from it, and what value they return after a write. Furthermore within each set there are subsets that allow for either a read or write to be combined with a integral operator, all done in one atomic operation. Each subset consists of various overloads to provide atomics not only for booleans and integers, but for real numbers and pointers as well.
    * 
    * @note
    *   Any 64-bit functionality only works when compiling for 64-bit processors. This is because the nkr::word_t of the machine is the maximum number of bits that can be used atomically.
    * @par
    * 
    * @note
    *   In the description for each function is an expression that equates semantically but not literally. Even though there are sometimes several operations in some of the expressions, each function is still atomically thread-safe.
    * @par
    * 
    * @note
    *   Without exception, every right-hand operand is statically cast to the left-hand sides underlying type, which conforms to operating system functions which may or may not be available. Either way, the pattern remains consistent.
    * @par
    */

        // Access
        /**
        * @class _ebc609cf_5026_47e9_87e7_c8ea9ecc71a9
        * @private
        * 
        * @brief
        *   These return a copy of the atomic value without changing the original. You can combine this with other operators like you would any other variable.
        */

            // Access()
            /**
            * @class _7c65ec60_0408_4a55_8cb6_e01ed4e45aa8
            * @private
            * 
            * @brief
            *   Equivalent to `(atom)`
            */

        // Assign
        /**
        * @class _d42247f7_a7b1_442f_beef_c88857ee5682
        * @private
        *
        * @brief
        *   These return a copy of the atomic value after changing the original.
        */

            // Assign()
            /**
            * @class _fab7ff12_4852_456f_ad51_fc9ec8b5fb4f
            * @private
            *
            * @brief
            *   Equivalent to `(atom = with)`
            */

            // Assign_Add()
            /**
            * @class _ae07793f_9604_443c_901c_718a00cc093c
            * @private
            *
            * @brief
            *   Equivalent to `(atom += with)` and `(++atom)`
            */

            // Assign_Add(type_pointer_tr)
            /**
            * @class _cbe72d03_f920_4d4d_a53c_68537d91e06e
            * @private
            * 
            * @copydoc _ae07793f_9604_443c_901c_718a00cc093c
            * 
            * @snippet "./src/os.cpp" _611ac2c6_4f53_4b55_937e_8b1cebea5a35
            */

            // Assign_Subtract()
            /**
            * @class _61dc311f_27ca_49a9_950a_9f3c9171b715
            * @private
            *
            * @brief
            *   Equivalent to `(atom -= with)` and `(--atom)`
            */

            // Assign_Subtract(type_pointer_tr)
            /**
            * @class _165233f2_0ca5_45bf_9b4d_c09253b1700c
            * @private
            * 
            * @copydoc _61dc311f_27ca_49a9_950a_9f3c9171b715
            * 
            * @snippet "./src/os.cpp" _60a12b01_ce35_4373_a70f_4ed735555759
            */

            // Assign_Multiply()
            /**
            * @class _db2ab814_83b3_42b5_9c32_44dfe8126b9d
            * @private
            *
            * @brief
            *   Equivalent to `(atom *= with)`
            */

            // Assign_Divide()
            /**
            * @class _388e4f09_010e_4578_8cc7_2255da0a4b4c
            * @private
            *
            * @brief
            *   Equivalent to `(atom /= with)`
            */

            // Assign_Modulus()
            /**
            * @class _76252e5c_09e8_446b_82dc_295f1dc684d2
            * @private
            *
            * @brief
            *   Equivalent to `(atom %= with)`
            */

            // Assign_Or()
            /**
            * @class _3f60e4fa_e39f_4e59_b88c_610282e72227
            * @private
            *
            * @brief
            *   Equivalent to `(atom |= with)`
            */

            // Assign_And()
            /**
            * @class _50094866_0d5e_4d6e_8003_080350799b02
            * @private
            *
            * @brief
            *   Equivalent to `(atom &= with)`
            */

            // Assign_Xor()
            /**
            * @class _f6c4cd5b_7f03_477b_968b_b65a1d79c37b
            * @private
            *
            * @brief
            *   Equivalent to `(atom ^= with)`
            */

            // Assign_Left_Shift()
            /**
            * @class _1988a49f_e149_41e5_acf1_5ee55d64e7a9
            * @private
            *
            * @brief
            *   Equivalent to `(atom <<= with)`
            */

            // Assign_Right_Shift()
            /**
            * @class _33d2bc67_7ea7_4519_83e6_0145d0c4c10d
            * @private
            *
            * @brief
            *   Equivalent to `(atom >>= with)`
            */

        // Exchange
        /**
        * @class _73d8454a_28bc_4509_b695_6bd373d375f2
        * @private
        *
        * @brief
        *   These return a copy of the original value before operating upon it.
        * 
        * @details
        *   Many of these functions could actually be combined together into a simpler set amounting to the same functionality. However doing it this way allows for optimizations that otherwise would be missed. Some of these functions have direct operating system calls they can use while others are implemented using the Exchange_If_Equals functions. An implementor of the library can make use of this assortment of funcitons to add optimizations that even the operating system and compiler are missing by talking directly to the processor.
        * 
        * In any case, even the functions that are implemented with the Exchange_If_Equals functions are way faster than using other locking techniques and so everything in here is a good alternative if you can design your program to use them, either directly or through the nkr::atomic_T interface.
        */

            // Exchange()
            /**
            * @class _d3109948_6d58_465c_9c35_1b3bc078193b
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom = with, original)`
            */

            // Exchange_Add()
            /**
            * @class _1636a842_cd0e_4a20_a69b_08777cf45e13
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom += with, original)` and `(atom++)`
            */

            // Exchange_Add(type_pointer_tr)
            /**
            * @class _cc0888ae_0348_4464_8425_d59c2563a3b9
            * @private
            * 
            * @copydoc _1636a842_cd0e_4a20_a69b_08777cf45e13
            * 
            * @snippet "./src/os.cpp" _4d9f5f22_f8aa_4316_bd0d_f8739139bd4e
            */

            // Exchange_Subtract()
            /**
            * @class _be5c47cb_bbce_4c8f_b1c9_f6f5564b1727
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom -= with, original)` and `(atom--)`
            */

            // Exchange_Subtract(type_pointer_tr)
            /**
            * @class _4160b14b_f8e3_4e5b_8340_b8e9285d1caa
            * @private
            * 
            * @copydoc _be5c47cb_bbce_4c8f_b1c9_f6f5564b1727
            * 
            * @snippet "./src/os.cpp" _8055b945_5e3d_4f07_96aa_f29e46a91dc2
            */

            // Exchange_Multiply()
            /**
            * @class _9b10e14c_d868_4740_b2dd_40ee361019f0
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom *= with, original)`
            */

            // Exchange_Divide()
            /**
            * @class _0c2871ea_dbfa_4075_bee1_84f0017ec54c
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom /= with, original)`
            */

            // Exchange_Modulus()
            /**
            * @class _75c6f727_7922_4ce2_8650_5c94e52b180e
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom %= with, original)`
            */

            // Exchange_Or()
            /**
            * @class _67e27237_78f0_4fe0_b667_15076d266dbc
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom |= with, original)`
            */

            // Exchange_And()
            /**
            * @class _43f052df_aa5c_4c1d_be58_1059147ba0c1
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom &= with, original)`
            */

            // Exchange_Xor()
            /**
            * @class _46e8118f_a77b_41c8_9f75_d1953aad71d8
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom ^= with, original)`
            */

            // Exchange_Left_Shift()
            /**
            * @class _a5e26340_6895_4258_ab06_7f6968cd5830
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom <<= with, original)`
            */

            // Exchange_Right_Shift()
            /**
            * @class _37998d5d_eb21_4e93_83bf_ef1bfb1152c7
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom >>= with, original)`
            */

            // Exchange_If_Equals()
            /**
            * @class _58b2d01f_9868_4a75_a3c8_da7371ab555e
            * @private
            *
            * @brief
            *   Equivalent to `(atom == snapshot ? (atom = with, true) : (snapshot = atom, false))`
            */

    // nkr::os::endian
    /**
    * @class _652312c1_72a2_4b36_88ab_aee6adf8e9c9
    * @private
    *
    * @brief
    *   Functions that provide various information and solutions regarding endianness.
    */

        // Info
        /**
        * @class _026b191f_2e76_4010_9760_e1215a647d9c
        * @private
        *
        * @brief
        *   Attain info regarding the endianness of the current processor you're running on.
        *
        * @details
        *   This is a thread-safe and efficient way of determining whether or not a computer is processing data in big or little endian. This is important to know when dealing with data that may have been written by or is intended to be read by another computer that has a different endianness than the one you are operating on. There are times when you need to know if you should swap your compound integer types to a different endianness or not.
        * 
        * @note
        *   The first time either of these functions are called they will be slightly inefficient, however any sucessive calls will be lightning fast.
        */

            // Is_Big()
            /**
            * @class _9d5ef4e6_ff8f_4d63_9fdc_0c0422259d90
            * @private
            * 
            * @snippet "./src/os.cpp" _2367da3d_58c3_4a8f_98c4_c9d8c809cb25
            */

            // Is_Little()
            /**
            * @class _884ae9eb_da64_4306_aab9_50aeb3f85298
            * @private
            * 
            * @snippet "./src/os.cpp" _e5a7621e_6b04_42ef_b8d2_94d576abb57e
            */

        // Swap
        /**
        * @class _b5b179fb_1f64_485e_9510_80260e3a6c33
        * @private
        *
        * @brief
        *   Invert the order of bytes in a multi-byte number.
        * 
        * @details
        *   These are useful when you are dealing with data that was either written by or will be read by a processor that has a different endianness than the one your program is executing on.
        *
        * @note
        *   There is no nkr::integer_8_tr variant because a byte or a stream of bytes cannot have a different endianness but is read and written the same on both kinds of computers.
        * @par
        * 
        * @note
        *   You need to be careful when trying to swap literal numbers as shown in the following example:
        * @par
        * 
        * @snippet "./src/os.cpp" _8204605f_3b41_4633_8865_89d336420022
        */

            // Swap(integer_16_tr)
            /**
            * @class _857ce8b6_02ca_48e5_9d19_4a7581b8e4c6
            * @private
            * 
            * @snippet "./src/os.cpp" _6bc67519_2af0_4999_a15c_ad085acb68e4
            * @snippet "./src/os.cpp" _962de4de_8f29_4f35_9ffb_123ac19b3cf8
            */

            // Swap(integer_32_tr)
            /**
            * @class _02c0499c_c8c8_43b9_8afc_96545310eb3a
            * @private
            * 
            * @snippet "./src/os.cpp" _d480540a_cabf_45d6_b3dc_0882dca2569b
            * @snippet "./src/os.cpp" _59caf647_91bb_4926_b0d0_401183e97ded
            */

            // Swap(integer_64_tr)
            /**
            * @class _eabf9a88_080f_445d_88ab_b0dae4a55316
            * @private
            * 
            * @snippet "./src/os.cpp" _52a0d032_dab3_4a2e_a06a_67bc56f297f4
            * @snippet "./src/os.cpp" _70f7b676_8069_4eec_93bf_007c172f1e39
            */

    // nkr::os::heap
    /**
    * @class _a6c4699b_8fe4_4664_ac57_062765decc2b
    * @private
    *
    * @brief
    *   Functions that interface with memory located on the heap.
    */

        // Allocation
        /**
        * @class _30c0ffe4_d85f_45e5_ab29_bd3f18629cb9
        * @private
        *
        * @brief
        *   Borrow a certain amount of memory from the heap. Use it, expand it, and give it back.
        */

            // Allocate()
            /**
            * @class _52a0d839_49c8_4d77_93b1_353137fecd3b
            * @private
            *
            * @brief
            *   Gives you memory to use until you deallocate it or your program exits.
            * 
            * @param units
            *   is the pointer that may be set to point to the allocated memory.
            * 
            * @param unit_count
            *   is the number of units (type instances) that will be allocated. It must be greater than zero.
            *
            * @returns
            *   `true` if it succeeds, setting units to the allocated pointer.
            * 
            * @returns
            *   `false` if it fails, setting units to `nullptr`.
            * 
            * @details
            *   There are a few limitations to the number of bytes you can allocate depending on:
            * 
            *   1. how much ram is physically in the computer
            *   2. how much space the operating system has left to give
            *   3. the settings that your compiler operates with
            *   4. what the natural word size of the processor is
            * 
            *   At most the largest number of bytes you will be able to allocate is the max number that can fit in an nkr::count_t (an alias of nkr::word_t). If you are running on a 32 bit processor you will only be able to allocate one byte shy of 4gb, which is no where near the amount of memory you can allocate on a 64 bit processor. Furthermore, limitations may come into play depending on the operating system, which may significantly decrease that amount even further.
            * 
            * @snippet "./src/os.cpp" _a06ecc73_e7ac_43b2_b231_059675458c15
            */

            // Reallocate()
            /**
            * @class _06fa627b_ba42_4b70_b0dd_66146e6d863a
            * @private
            *
            * @brief
            *   Gives you more memory while keeping all your data intact.
            *
            * @param units
            *   should be a pointer set by nkr::os::heap::Allocate or nkr::os::heap::Reallocate. When successful, it will be set to a new pointer if necessary, or else it will be left unchanged.
            *
            * @param new_unit_count
            *   is the total number of units (type instances) that may be allocated after this function returns. It should be the total size you want the memory to be. It must be greater than zero.
            *
            * @returns
            *   `true` if it succeeds, setting units to a different allocated pointer if necessary, else leaving it alone.
            *
            * @returns
            *   `false` when it fails, leaving units alone.
            *
            * @details
            *   This will allocate more memory for you if the new count is greater than the currently allocated count. Otherwise, it will simply return as if it had succeeded, with no changes to the pointer. See nkr::os::heap::Allocate for more details about allocation generally.
            *
            * @note
            *   This cannot shrink the memory you allocate, but some higher level types in the library may by request.
            * @par
            * 
            * @todo
            *   Maybe return an enum_t to indicate different kinds of failures?
            * @par
            * 
            * @snippet "./src/os.cpp" _3c97398a_6fe6_4b47_81a2_18efd5ab72d5
            */

            // Deallocate()
            /**
            * @class _de0237bf_9b0a_47fc_a5ab_99f21504f570
            * @private
            *
            * @brief
            *   Takes back memory you no longer need so it can be reused later.
            *
            * @param units
            *   should be a pointer set by nkr::os::heap::Allocate or nkr::os::heap::Reallocate. It will be set to `nullptr` after deallocation. If it is already `nullptr`, the function returns as if it was already successful.
            *
            * @details
            *   When using these functions, memory will never be deallocated automatically for you like it is in some higher level types. You will have to manually deallocate every pointer you allocate, or else you may unexpectedly run out of memory. Regardless, the operating system will deallocate everything that has not already been deallocated when your program exits.
            * 
            * @snippet "./src/os.cpp" _09113b05_5f70_459c_9827_f53c58816243
            */

        // Zero-Initialized Allocation
        /**
        * @class _eca47636_431b_4d2a_a102_679075b3cf17
        * @private
        *
        * @brief
        *   A variant of regular allocation, all the values in your memory will be initialized to zero.
        */

            // Allocate_Zeros()
            /**
            * @class _9c5a7296_5644_47bf_bd3f_ff7de3518ce9
            * @private
            *
            * @brief
            *   Gives you zero-initialized memory to use until your program exits.
            *
            * @param units
            *   is the pointer that may be set to point to the allocated memory.
            * 
            * @param unit_count
            *   is the number of units (type instances) that will be allocated. It must be greater than zero.
            *
            * @returns
            *   `true` if it succeeds, setting units to the allocated pointer.
            * 
            * @returns
            *   `false` if it fails, setting units to `nullptr`.
            *
            * @details
            *   This uses an efficient operating system dependent algorithm to avoid zeroing out all values during runtime. Normally the os will keep pages of zero initialized bytes ready for allocation and it will only need to initialize them on the occasion that it doesn't have any of those pages readily available. Please see nkr::os::heap::Allocate for more details.
            *
            * @note
            *   The returned pointer can be used with nkr::os::heap::Reallocate to allocate more memory but without it being zero-intialized, and nkr::os::heap::Deallocate to free the memory. Both of these are currently frowned upon because they may not work in future updates or on certain operating systems.
            * @par
            * 
            * @snippet "./src/os.cpp" _fc02c748_8572_4062_b2b1_8cfaa78bc002
            */

            // Reallocate_Zeros()
            /**
            * @class _7d7887a0_3e2d_4502_af8c_d409aae73f0b
            * @private
            * 
            * @brief
            *   Gives you more zero-initialized memory while keeping all your data intact.
            *
            * @param units
            *   should be a pointer set by nkr::os::heap::Allocate_Zeros or nkr::os::heap::Reallocate_Zeros. When successful, it will be set to a new pointer if necessary, or else it will be left unchanged.
            *
            * @param new_unit_count
            *   is the total number of units (type instances) that may be allocated after this function returns. It should be the total size you want the memory to be. It must be greater than zero.
            *
            * @returns
            *   `true` if it succeeds, setting units to a different allocated pointer if necessary, else leaving it alone.
            *
            * @returns
            *   `false` when it fails, leaving units alone.
            *
            * @details
            *   Please see nkr::os::heap::Reallocate for more details.
            * 
            * @snippet "./src/os.cpp" _831dc6ca_17bd_4515_9fd9_48f36c1014da
            */

            // Deallocate_Zeros()
            /**
            * @class _04d9a3fe_30b3_4ae2_bbc4_2a3cfc4768d6
            * @private
            * 
            * @brief
            *   Takes back memory you no longer need so it can be reused later.
            *
            * @param units
            *   should be a pointer set by nkr::os::heap::Allocate_Zeros or nkr::os::heap::Reallocate_Zeros. It will be set to `nullptr` after deallocation. If it is already `nullptr`, the function returns as if it was already successful.
            *
            * @details
            *   Please see nkr::os::heap::Deallocate for more details.
            * 
            * @note
            *   This does not zero the memory.
            * @par
            * 
            * @snippet "./src/os.cpp" _6c279b29_119d_4ca0_8c6a_552cb9ea6431
            */
