/*
    Copyright 2021 r-neal-kelly
*/

/**
* @class doc_nkr_os
* @private
*
* @brief
*   Short for "Operating System", this contains several wrappers for otherwise platform specific functionality.
*/

    /**
    * @class doc_nkr_os_atomic
    * @private
    *
    * @brief
    *   Functions that provide atomic access, assignment, and exchange of variables.
    * 
    * @details
    *   These functions can be used in a threaded environment to safely read and write to various integers, booleans, and pointers. They are far more resource friendly than locks and should be used in their place as frequently as possible.
    * 
    *   There are three primary sets of these low level atomic functions, each differing in whether they write to the atomic or simply read from it, and what value they return after a write. Furthermore within each set there are at least six subsets that allow for either a read or write to be combined with a integral operator, all done in one atomic operation. Each subset may consist of one to two overloads to provide atomics not only for integers and booleans, but for pointers as well.
    * 
    * @note
    *   In the description for each function is an expression that equates semantically but not literally. Even though there are sometimes several operations in some of the expressions, each function is still atomically thread-safe.
    */

        /**
        * @class doc_nkr_os_atomic_group_Access
        * @private
        * 
        * @brief
        *   These return a copy of the atomic value without changing the original.
        */

            // boolean_tr auto Access(const volatile boolean_tr auto& atom)
            /**
            * @class _f108db58_8738_44fc_8660_a9f2806661f3
            * @private
            *
            * @brief
            *   Equivalent to `(atom)`
            */

            /**
            * @class doc_nkr_os_atomic_Access
            * @private
            * 
            * @brief
            *   Equivalent to `(atom)`
            */

            /**
            * @class doc_nkr_os_atomic_Access_Add
            * @private
            *
            * @brief
            *   Equivalent to `(atom + with)`
            */

            /**
            * @class doc_nkr_os_atomic_Access_Subtract
            * @private
            *
            * @brief
            *   Equivalent to `(atom - with)`
            */

            /**
            * @class doc_nkr_os_atomic_Access_Or
            * @private
            *
            * @brief
            *   Equivalent to `(atom | with)`
            */

            /**
            * @class doc_nkr_os_atomic_Access_And
            * @private
            *
            * @brief
            *   Equivalent to `(atom & with)`
            */

            /**
            * @class doc_nkr_os_atomic_Access_Xor
            * @private
            *
            * @brief
            *   Equivalent to `(atom ^ with)`
            */

        /**
        * @class doc_nkr_os_atomic_group_Assign
        * @private
        *
        * @brief
        *   These return a copy of the atomic value after changing the original.
        */

            // boolean_tr auto Assign(volatile boolean_tr auto& atom, boolean_tr auto with)
            /**
            * @class _5c4929b4_7b2c_49b7_946a_1dc7085f362c
            * @private
            *
            * @brief
            *   Equivalent to `(atom = with)`
            */

            /**
            * @class doc_nkr_os_atomic_Assign
            * @private
            *
            * @brief
            *   Equivalent to `(atom = with)`
            */

            /**
            * @class doc_nkr_os_atomic_Assign_Add
            * @private
            *
            * @brief
            *   Equivalent to `(atom += with)` and `(++atom)`
            */

            /**
            * @class doc_nkr_os_atomic_Assign_Subtract
            * @private
            *
            * @brief
            *   Equivalent to `(atom -= with)` and `(--atom)`
            */

            /**
            * @class doc_nkr_os_atomic_Assign_Or
            * @private
            *
            * @brief
            *   Equivalent to `(atom |= with)`
            */

            /**
            * @class doc_nkr_os_atomic_Assign_And
            * @private
            *
            * @brief
            *   Equivalent to `(atom &= with)`
            */

            /**
            * @class doc_nkr_os_atomic_Assign_Xor
            * @private
            *
            * @brief
            *   Equivalent to `(atom ^= with)`
            */

        /**
        * @class doc_nkr_os_atomic_group_Exchange
        * @private
        *
        * @brief
        *   These return a copy of the atomic value before changing the original.
        */

            // boolean_tr auto     Exchange(volatile boolean_tr auto& atom, boolean_tr auto with)
            /**
            * @class _acf46593_b662_4d8a_9596_25f347ef5cbf
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom = with, original)`
            */

            /**
            * @class doc_nkr_os_atomic_Exchange
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom = with, original)`
            */

            // boolean_tr auto     Exchange_If_Equals(volatile boolean_tr auto& atom, boolean_tr auto with, boolean_tr auto target)
            /**
            * @class _6705c0d6_baf4_4cd6_b4bf_727403e9d2c2
            * @private
            *
            * @brief
            *   Equivalent to `(atom == target ? (original = atom, atom = with, original) : (atom))`
            */

            /**
            * @class doc_nkr_os_atomic_Exchange_If_Equals
            * @private
            *
            * @brief
            *   Equivalent to `(atom == target ? (original = atom, atom = with, original) : (atom))`
            */

            /**
            * @class doc_nkr_os_atomic_Exchange_Add
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom += with, original)` and `(atom++)`
            */

            /**
            * @class doc_nkr_os_atomic_Exchange_Subtract
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom -= with, original)` and `(atom--)`
            */

            /**
            * @class doc_nkr_os_atomic_Exchange_Or
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom |= with, original)`
            */

            /**
            * @class doc_nkr_os_atomic_Exchange_And
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom &= with, original)`
            */

            /**
            * @class doc_nkr_os_atomic_Exchange_Xor
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom ^= with, original)`
            */

    /**
    * @class doc_nkr_os_endian
    * @private
    *
    * @brief
    *   Functions that provide various information and solutions regarding endianness.
    */

        /**
        * @class doc_nkr_os_endian_group_info
        * @private
        *
        * @brief
        *   Attain info regarding the endianness of the current processor you're running on.
        *
        * @details
        *   This is a thread-safe and efficient way of determining whether or not a computer is processing data in big or little endian. This is important to know when dealing with data that may have been written by or is intended to be read by another computer that has a different endianness than the one you are operating on. There are times when you need to know if you should swap your compound integer types to a different endianness or not.
        * 
        * @note
        *   The first time either of these functions are called they will be slightly inefficient, however any sucessive calls will be lightning fast.
        */

            /**
            * @class doc_nkr_os_endian_Is_Big
            * @private
            */

            /**
            * @class doc_nkr_os_endian_Is_Little
            * @private
            */

        /**
        * @class doc_nkr_os_endian_group_swap
        * @private
        *
        * @brief
        *   Invert the order of bytes in a multi-byte number.
        * 
        * @details
        *   These are useful when you are dealing with data that was either written by or will be read by a processor that has a different endianness than the one your program is executing on.
        *
        * @note
        *   There is no nkr::integer_8_tr variant because a byte or a stream of bytes cannot have a different endianness but is read and written the same on both kinds of computers.
        */

            /**
            * @class doc_nkr_os_endian_Swap_16
            * @private
            */

            /**
            * @class doc_nkr_os_endian_Swap_32
            * @private
            */

            /**
            * @class doc_nkr_os_endian_Swap_64
            * @private
            */

    /**
    * @class doc_nkr_os_heap
    * @private
    *
    * @brief
    *   Functions that interface with memory located on the heap.
    */

        /**
        * @class doc_nkr_os_heap_group_allocation
        * @private
        *
        * @brief
        *   Borrow a certain amount of memory from the heap. Use it, expand it, and give it back.
        */

            /**
            * @class doc_nkr_os_heap_Allocate
            * @private
            *
            * @brief
            *   Gives you memory to use until you deallocate it or your program exits.
            * 
            * @param byte_count
            *   must be greater than zero.
            *
            * @returns
            *   a pointer to the allocated bytes when it succeeds.
            *
            * @returns
            *   a `nullptr` when it fails.
            * 
            * @details
            *   There are a few limitations to the number of bytes you can allocate depending on:
            * 
            *   1. how much ram is physically in the computer
            *   2. how much space the operating system has left to give
            *   3. the settings that your compiler operates with
            *   4. what the natural word size of the processor is
            * 
            *   At most the largest number of bytes you will be able to allocate is the max number that can fit in an nkr::count_t (an alias of nkr::word_t). If you are running on a 32 bit processor you will only be able to allocate one byte shy of 4gb, which is no where near the amount of memory you can allocate on a 64 bit processor. Furthermore, limitations may come into play depending on the operating system, which may significantly decrease that amount even further.
            */

            /**
            * @class doc_nkr_os_heap_Reallocate
            * @private
            *
            * @brief
            *   Gives you more memory while keeping all your data intact.
            *
            * @param bytes
            *   should be a pointer returned by nkr::os::heap::Allocate. When successful, it will be set to a new pointer if necessary, or else it will be left unchanged.
            *
            * @param new_byte_count
            *   must be greater than zero.
            *
            * @returns
            *   `true` when it succeeds.
            *
            * @returns
            *   `false` when it fails.
            *
            * @details
            *   This will allocate more memory for you if `new_byte_count` is greater than the currently allocated `byte_count`, which is stored internally in the operating system. Otherwise, it will simply return as if it had succeeded, with no changes to `bytes`. See nkr::os::heap::Allocate for more details about allocation generally.
            *
            * @note
            *   This cannot shrink the memory you allocate, but some higher level types in the library can by request.
            *
            * @todo
            *   Maybe return an enum_t to indicate different kinds of failures, at least on Windows.
            */

            /**
            * @class doc_nkr_os_heap_Deallocate
            * @private
            *
            * @brief
            *   Takes back memory you no longer need so it can be reused later.
            *
            * @param bytes
            *   should be a pointer returned by nkr::os::heap::Allocate. It will be set to `nullptr` after deallocation.
            *
            * @details
            *   When using these functions, memory will never be deallocated automatically for you like it is in some higher level types. You will have to manually deallocate every pointer you allocate, or else you may unexpectedly run out of memory. Regardless, the operating system will deallocate everything that has not already been deallocated when your program exits.
            */

        /**
        * @class doc_nkr_os_heap_group_allocation_zero
        * @private
        *
        * @brief
        *   A variant of regular allocation, all the values in your memory will be initialized to zero.
        */

            /**
            * @class doc_nkr_os_heap_Allocate_Zeros
            * @private
            *
            * @brief
            *   Gives you zero-initialized memory to use until your program exits.
            *
            * @param byte_count
            *   must be greater than zero.
            *
            * @returns
            *   a pointer to the allocated zero-initialized bytes when it succeeds.
            *
            * @returns
            *   a `nullptr` when it fails.
            *
            * @details
            *   This uses an efficient operating system dependent algorithm to avoid zeroing out all values during runtime. Normally the os will keep pages of zero initialized bytes ready for allocation and it will only need to initialize them on the occasion that it doesn't have any of those pages readily available. Please see nkr::os::heap::Allocate for more details.
            *
            * @note
            *   The returned pointer can be used with nkr::os::heap::Reallocate to allocate more memory but without it being zero-intialized, and nkr::os::heap::Deallocate to free the memory. Both of these are currently frowned upon because they may not work in future updates or on certain operating systems.
            */

            /**
            * @class doc_nkr_os_heap_Reallocate_Zeros
            * @private
            * 
            * @brief
            *   Gives you more zero-initialized memory while keeping all your data intact.
            *
            * @param bytes
            *   should be a pointer returned by nkr::os::heap::Allocate_Zeros. When successful, it will be set to a new pointer if necessary, or else it will be left unchanged.
            *
            * @param new_byte_count
            *   must be greater than zero.
            *
            * @returns
            *   `true` when it succeeds.
            *
            * @returns
            *   `false` when it fails.
            *
            * @details
            *   Please see nkr::os::heap::Reallocate for more details.
            */

            /**
            * @class doc_nkr_os_heap_Deallocate_Zeros
            * @private
            * 
            * @brief
            *   Takes back memory you no longer need so it can be reused later.
            *
            * @param bytes
            *   should be a pointer returned by nkr::os::heap::Allocate_Zeros. It will be set to `nullptr` after deallocation.
            *
            * @details
            *   Please see nkr::os::heap::Deallocate for more details.
            *
            * @note
            *   This does not zero the memory.
            */
