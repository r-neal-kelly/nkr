/*
    Copyright 2021 r-neal-kelly
*/

/**
* @class doc_nkr_os
* @private
*
* @brief
*   Short for "Operating System", this contains several wrappers for otherwise platform specific functionality.
*/

    /**
    * @class doc_nkr_os_atomic
    * @private
    *
    * @brief
    *   Functions that provide atomic access, assignment, and exchange of variables.
    * 
    * @details
    *   These functions can be used in a threaded environment to safely read and write to various integers, booleans, and pointers. They are far more resource friendly than locks and should be used in their place as frequently as possible.
    * 
    *   There are three primary sets of these low level atomic functions, each differing in whether they write to the atomic or simply read from it, and what value they return after a write. Furthermore within each set there are at least six subsets that allow for either a read or write to be combined with a integral operator, all done in one atomic operation. Each subset may consist of one to two overloads to provide atomics not only for integers and booleans, but for pointers as well.
    * 
    * @note
    *   In the description for each function is an expression that equates semantically but not literally. Even though there are sometimes several operations in some of the expressions, each function is still atomically thread-safe.
    */

        /**
        * @class doc_nkr_os_atomic_group_Access
        * @private
        * 
        * @brief
        *   These return a copy of the atomic value without changing the original.
        */

            // Access(boolean_tr)
            /**
            * @class _f108db58_8738_44fc_8660_a9f2806661f3
            * @private
            *
            * @brief
            *   Equivalent to `(atom)`
            */

            /**
            * @class doc_nkr_os_atomic_Access
            * @private
            * 
            * @brief
            *   Equivalent to `(atom)`
            */

            /**
            * @class doc_nkr_os_atomic_Access_Add
            * @private
            *
            * @brief
            *   Equivalent to `(atom + with)`
            */

            /**
            * @class doc_nkr_os_atomic_Access_Subtract
            * @private
            *
            * @brief
            *   Equivalent to `(atom - with)`
            */

            /**
            * @class doc_nkr_os_atomic_Access_Or
            * @private
            *
            * @brief
            *   Equivalent to `(atom | with)`
            */

            /**
            * @class doc_nkr_os_atomic_Access_And
            * @private
            *
            * @brief
            *   Equivalent to `(atom & with)`
            */

            /**
            * @class doc_nkr_os_atomic_Access_Xor
            * @private
            *
            * @brief
            *   Equivalent to `(atom ^ with)`
            */

        /**
        * @class doc_nkr_os_atomic_group_Assign
        * @private
        *
        * @brief
        *   These return a copy of the atomic value after changing the original.
        */

            // Assign(boolean_tr)
            /**
            * @class _5c4929b4_7b2c_49b7_946a_1dc7085f362c
            * @private
            *
            * @brief
            *   Equivalent to `(atom = with)`
            */

            /**
            * @class doc_nkr_os_atomic_Assign
            * @private
            *
            * @brief
            *   Equivalent to `(atom = with)`
            */

            /**
            * @class doc_nkr_os_atomic_Assign_Add
            * @private
            *
            * @brief
            *   Equivalent to `(atom += with)` and `(++atom)`
            */

            /**
            * @class doc_nkr_os_atomic_Assign_Subtract
            * @private
            *
            * @brief
            *   Equivalent to `(atom -= with)` and `(--atom)`
            */

            /**
            * @class doc_nkr_os_atomic_Assign_Or
            * @private
            *
            * @brief
            *   Equivalent to `(atom |= with)`
            */

            /**
            * @class doc_nkr_os_atomic_Assign_And
            * @private
            *
            * @brief
            *   Equivalent to `(atom &= with)`
            */

            /**
            * @class doc_nkr_os_atomic_Assign_Xor
            * @private
            *
            * @brief
            *   Equivalent to `(atom ^= with)`
            */

        /**
        * @class doc_nkr_os_atomic_group_Exchange
        * @private
        *
        * @brief
        *   These return a copy of the atomic value before changing the original.
        */

            // Exchange(boolean_tr)
            /**
            * @class _acf46593_b662_4d8a_9596_25f347ef5cbf
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom = with, original)`
            */

            /**
            * @class doc_nkr_os_atomic_Exchange
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom = with, original)`
            */

            /**
            * @class doc_nkr_os_atomic_Exchange_Add
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom += with, original)` and `(atom++)`
            */

            /**
            * @class doc_nkr_os_atomic_Exchange_Subtract
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom -= with, original)` and `(atom--)`
            */

            /**
            * @class doc_nkr_os_atomic_Exchange_Or
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom |= with, original)`
            */

            /**
            * @class doc_nkr_os_atomic_Exchange_And
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom &= with, original)`
            */

            /**
            * @class doc_nkr_os_atomic_Exchange_Xor
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom ^= with, original)`
            */

            // Exchange_If_Equals(boolean_tr);
            /**
            * @class _6705c0d6_baf4_4cd6_b4bf_727403e9d2c2
            * @private
            *
            * @brief
            *   Equivalent to `(atom == target ? (original = atom, atom = with, original) : (atom))`
            */

            /**
            * @class doc_nkr_os_atomic_Exchange_If_Equals
            * @private
            *
            * @brief
            *   Equivalent to `(atom == target ? (original = atom, atom = with, original) : (atom))`
            */

    /**
    * @class doc_nkr_os_endian
    * @private
    *
    * @brief
    *   Functions that provide various information and solutions regarding endianness.
    */

        /**
        * @class doc_nkr_os_endian_group_info
        * @private
        *
        * @brief
        *   Attain info regarding the endianness of the current processor you're running on.
        *
        * @details
        *   This is a thread-safe and efficient way of determining whether or not a computer is processing data in big or little endian. This is important to know when dealing with data that may have been written by or is intended to be read by another computer that has a different endianness than the one you are operating on. There are times when you need to know if you should swap your compound integer types to a different endianness or not.
        * 
        * @note
        *   The first time either of these functions are called they will be slightly inefficient, however any sucessive calls will be lightning fast.
        */

            /**
            * @class doc_nkr_os_endian_Is_Big
            * @private
            */

            /**
            * @class doc_nkr_os_endian_Is_Little
            * @private
            */

        /**
        * @class doc_nkr_os_endian_group_swap
        * @private
        *
        * @brief
        *   Invert the order of bytes in a multi-byte number.
        * 
        * @details
        *   These are useful when you are dealing with data that was either written by or will be read by a processor that has a different endianness than the one your program is executing on.
        *
        * @note
        *   There is no nkr::integer_8_tr variant because a byte or a stream of bytes cannot have a different endianness but is read and written the same on both kinds of computers.
        */

            /**
            * @class doc_nkr_os_endian_Swap_16
            * @private
            */

            /**
            * @class doc_nkr_os_endian_Swap_32
            * @private
            */

            /**
            * @class doc_nkr_os_endian_Swap_64
            * @private
            */

    /**
    * @class doc_nkr_os_heap
    * @private
    *
    * @brief
    *   Functions that interface with memory located on the heap.
    */

        // allocation
        /**
        * @class _30c0ffe4_d85f_45e5_ab29_bd3f18629cb9
        * @private
        *
        * @brief
        *   Borrow a certain amount of memory from the heap. Use it, expand it, and give it back.
        */

            // Allocate()
            /**
            * @class _52a0d839_49c8_4d77_93b1_353137fecd3b
            * @private
            *
            * @brief
            *   Gives you memory to use until you deallocate it or your program exits.
            * 
            * @param units
            *   is the pointer that may be set to point to the allocated memory.
            * 
            * @param unit_count
            *   is the number of units (type instances) that will be allocated. It must be greater than zero.
            *
            * @returns
            *   `true` if it succeeds, setting units to the allocated pointer.
            * 
            * @returns
            *   `false` if it fails, setting units to `nullptr`.
            * 
            * @details
            *   There are a few limitations to the number of bytes you can allocate depending on:
            * 
            *   1. how much ram is physically in the computer
            *   2. how much space the operating system has left to give
            *   3. the settings that your compiler operates with
            *   4. what the natural word size of the processor is
            * 
            *   At most the largest number of bytes you will be able to allocate is the max number that can fit in an nkr::count_t (an alias of nkr::word_t). If you are running on a 32 bit processor you will only be able to allocate one byte shy of 4gb, which is no where near the amount of memory you can allocate on a 64 bit processor. Furthermore, limitations may come into play depending on the operating system, which may significantly decrease that amount even further.
            */

            // Reallocate()
            /**
            * @class _06fa627b_ba42_4b70_b0dd_66146e6d863a
            * @private
            *
            * @brief
            *   Gives you more memory while keeping all your data intact.
            *
            * @param units
            *   should be a pointer set by nkr::os::heap::Allocate or nkr::os::heap::Reallocate. When successful, it will be set to a new pointer if necessary, or else it will be left unchanged.
            *
            * @param new_unit_count
            *   is the total number of units (type instances) that may be allocated after this function returns. It should be the total size you want the memory to be. It must be greater than zero.
            *
            * @returns
            *   `true` if it succeeds, setting units to a different allocated pointer if necessary, else leaving it alone.
            *
            * @returns
            *   `false` when it fails, leaving units alone.
            *
            * @details
            *   This will allocate more memory for you if the new count is greater than the currently allocated count. Otherwise, it will simply return as if it had succeeded, with no changes to the pointer. See nkr::os::heap::Allocate for more details about allocation generally.
            *
            * @note
            *   This cannot shrink the memory you allocate, but some higher level types in the library may by request.
            *
            * @todo
            *   Maybe return an enum_t to indicate different kinds of failures, at least on Windows?
            */

            // Deallocate()
            /**
            * @class _de0237bf_9b0a_47fc_a5ab_99f21504f570
            * @private
            *
            * @brief
            *   Takes back memory you no longer need so it can be reused later.
            *
            * @param units
            *   should be a pointer set by nkr::os::heap::Allocate or nkr::os::heap::Reallocate. It will be set to `nullptr` after deallocation. If it is already `nullptr`, the function returns as if it was already successful.
            *
            * @details
            *   When using these functions, memory will never be deallocated automatically for you like it is in some higher level types. You will have to manually deallocate every pointer you allocate, or else you may unexpectedly run out of memory. Regardless, the operating system will deallocate everything that has not already been deallocated when your program exits.
            */

        // zero-initialized allocation
        /**
        * @class _eca47636_431b_4d2a_a102_679075b3cf17
        * @private
        *
        * @brief
        *   A variant of regular allocation, all the values in your memory will be initialized to zero.
        */

            // Allocate_Zeros()
            /**
            * @class _9c5a7296_5644_47bf_bd3f_ff7de3518ce9
            * @private
            *
            * @brief
            *   Gives you zero-initialized memory to use until your program exits.
            *
            * @param units
            *   is the pointer that may be set to point to the allocated memory.
            * 
            * @param unit_count
            *   is the number of units (type instances) that will be allocated. It must be greater than zero.
            *
            * @returns
            *   `true` if it succeeds, setting units to the allocated pointer.
            * 
            * @returns
            *   `false` if it fails, setting units to `nullptr`.
            *
            * @details
            *   This uses an efficient operating system dependent algorithm to avoid zeroing out all values during runtime. Normally the os will keep pages of zero initialized bytes ready for allocation and it will only need to initialize them on the occasion that it doesn't have any of those pages readily available. Please see nkr::os::heap::Allocate for more details.
            *
            * @note
            *   The returned pointer can be used with nkr::os::heap::Reallocate to allocate more memory but without it being zero-intialized, and nkr::os::heap::Deallocate to free the memory. Both of these are currently frowned upon because they may not work in future updates or on certain operating systems.
            */

            // Reallocate_Zeros()
            /**
            * @class _7d7887a0_3e2d_4502_af8c_d409aae73f0b
            * @private
            * 
            * @brief
            *   Gives you more zero-initialized memory while keeping all your data intact.
            *
            * @param units
            *   should be a pointer set by nkr::os::heap::Allocate_Zeros or nkr::os::heap::Reallocate_Zeros. When successful, it will be set to a new pointer if necessary, or else it will be left unchanged.
            *
            * @param new_unit_count
            *   is the total number of units (type instances) that may be allocated after this function returns. It should be the total size you want the memory to be. It must be greater than zero.
            *
            * @returns
            *   `true` if it succeeds, setting units to a different allocated pointer if necessary, else leaving it alone.
            *
            * @returns
            *   `false` when it fails, leaving units alone.
            *
            * @details
            *   Please see nkr::os::heap::Reallocate for more details.
            */

            // Deallocate_Zeros()
            /**
            * @class _04d9a3fe_30b3_4ae2_bbc4_2a3cfc4768d6
            * @private
            * 
            * @brief
            *   Takes back memory you no longer need so it can be reused later.
            *
            * @param units
            *   should be a pointer set by nkr::os::heap::Allocate_Zeros or nkr::os::heap::Reallocate_Zeros. It will be set to `nullptr` after deallocation. If it is already `nullptr`, the function returns as if it was already successful.
            *
            * @details
            *   Please see nkr::os::heap::Deallocate for more details.
            *
            * @note
            *   This does not zero the memory.
            */
