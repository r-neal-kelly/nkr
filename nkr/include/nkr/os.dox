/*
    Copyright 2021 r-neal-kelly
*/

// nkr::os
/**
* @class _ae5b9a84_c87b_4c0a_b714_4933761921d7
* @private
*
* @brief
*   Short for "Operating System", this contains several wrappers for otherwise platform specific functionality.
*/

    // nkr::os::atomic
    /**
    * @class _a6ff4022_7389_4e35_b146_066ce313290e
    * @private
    *
    * @brief
    *   Functions that provide atomic access, assignment, and exchange of variables.
    * 
    * @details
    *   These functions can be used in a threaded environment to safely read and write to various integers, booleans, and pointers. They are far more resource friendly than locks and should be used in their place as frequently as possible.
    * 
    *   There are three primary sets of these low level atomic functions, each differing in whether they write to the atomic or simply read from it, and what value they return after a write. Furthermore within each set there are at least six subsets that allow for either a read or write to be combined with a integral operator, all done in one atomic operation. Each subset may consist of one to two overloads to provide atomics not only for integers and booleans, but for pointers as well.
    * 
    * @note
    *   In the description for each function is an expression that equates semantically but not literally. Even though there are sometimes several operations in some of the expressions, each function is still atomically thread-safe.
    */

        // Access
        /**
        * @class _ebc609cf_5026_47e9_87e7_c8ea9ecc71a9
        * @private
        * 
        * @brief
        *   These return a copy of the atomic value without changing the original.
        */

            // Access(boolean_tr)
            /**
            * @class _f108db58_8738_44fc_8660_a9f2806661f3
            * @private
            *
            * @brief
            *   Equivalent to `(atom)`
            */

            /**
            * @class doc_nkr_os_atomic_Access
            * @private
            * 
            * @brief
            *   Equivalent to `(atom)`
            */

            /**
            * @class doc_nkr_os_atomic_Access_Add
            * @private
            *
            * @brief
            *   Equivalent to `(atom + with)`
            */

            /**
            * @class doc_nkr_os_atomic_Access_Subtract
            * @private
            *
            * @brief
            *   Equivalent to `(atom - with)`
            */

            /**
            * @class doc_nkr_os_atomic_Access_Or
            * @private
            *
            * @brief
            *   Equivalent to `(atom | with)`
            */

            /**
            * @class doc_nkr_os_atomic_Access_And
            * @private
            *
            * @brief
            *   Equivalent to `(atom & with)`
            */

            /**
            * @class doc_nkr_os_atomic_Access_Xor
            * @private
            *
            * @brief
            *   Equivalent to `(atom ^ with)`
            */

        // Assign
        /**
        * @class _d42247f7_a7b1_442f_beef_c88857ee5682
        * @private
        *
        * @brief
        *   These return a copy of the atomic value after changing the original.
        */

            // Assign(boolean_tr)
            /**
            * @class _5c4929b4_7b2c_49b7_946a_1dc7085f362c
            * @private
            *
            * @brief
            *   Equivalent to `(atom = with)`
            */

            /**
            * @class doc_nkr_os_atomic_Assign
            * @private
            *
            * @brief
            *   Equivalent to `(atom = with)`
            */

            /**
            * @class doc_nkr_os_atomic_Assign_Add
            * @private
            *
            * @brief
            *   Equivalent to `(atom += with)` and `(++atom)`
            */

            /**
            * @class doc_nkr_os_atomic_Assign_Subtract
            * @private
            *
            * @brief
            *   Equivalent to `(atom -= with)` and `(--atom)`
            */

            /**
            * @class doc_nkr_os_atomic_Assign_Or
            * @private
            *
            * @brief
            *   Equivalent to `(atom |= with)`
            */

            /**
            * @class doc_nkr_os_atomic_Assign_And
            * @private
            *
            * @brief
            *   Equivalent to `(atom &= with)`
            */

            /**
            * @class doc_nkr_os_atomic_Assign_Xor
            * @private
            *
            * @brief
            *   Equivalent to `(atom ^= with)`
            */

        // Exchange
        /**
        * @class _73d8454a_28bc_4509_b695_6bd373d375f2
        * @private
        *
        * @brief
        *   These return a copy of the original value before operating upon it.
        * 
        * @details
        *   Many of these functions could actually be combined together into a simpler set amounting to the same functionality. However doing it this way allows for optimizations that otherwise would be missed. Some of these functions have direct operating system calls they can use while others are implemented using the Exchange_If_Equals functions. An implementor of the library can make use of this assortment of funcitons to add optimizations that even the operating system and compiler are missing by talking directly to the processor.
        * 
        * In any case, even the functions that are implemented with the Exchange_If_Equals functions are way faster than using other locking techniques and so everything in here is a good alternative if you can design your program to use them, either directly or through the nkr::atomic_T interface.
        */

            // Exchange(boolean_tr)
            /**
            * @class _acf46593_b662_4d8a_9596_25f347ef5cbf
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom = with, original)`
            */

            /**
            * @class doc_nkr_os_atomic_Exchange
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom = with, original)`
            */

            /**
            * @class doc_nkr_os_atomic_Exchange_Add
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom += with, original)` and `(atom++)`
            */

            /**
            * @class doc_nkr_os_atomic_Exchange_Subtract
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom -= with, original)` and `(atom--)`
            */

            /**
            * @class doc_nkr_os_atomic_Exchange_Or
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom |= with, original)`
            */

            /**
            * @class doc_nkr_os_atomic_Exchange_And
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom &= with, original)`
            */

            /**
            * @class doc_nkr_os_atomic_Exchange_Xor
            * @private
            *
            * @brief
            *   Equivalent to `(original = atom, atom ^= with, original)`
            */

            // Exchange_If_Equals(boolean_tr);
            /**
            * @class _6705c0d6_baf4_4cd6_b4bf_727403e9d2c2
            * @private
            *
            * @brief
            *   Equivalent to `(atom == target ? (original = atom, atom = with, original) : (atom))`
            */

            /**
            * @class doc_nkr_os_atomic_Exchange_If_Equals
            * @private
            *
            * @brief
            *   Equivalent to `(atom == target ? (original = atom, atom = with, original) : (atom))`
            */

    // nkr::os::endian
    /**
    * @class _652312c1_72a2_4b36_88ab_aee6adf8e9c9
    * @private
    *
    * @brief
    *   Functions that provide various information and solutions regarding endianness.
    */

        // Info
        /**
        * @class _026b191f_2e76_4010_9760_e1215a647d9c
        * @private
        *
        * @brief
        *   Attain info regarding the endianness of the current processor you're running on.
        *
        * @details
        *   This is a thread-safe and efficient way of determining whether or not a computer is processing data in big or little endian. This is important to know when dealing with data that may have been written by or is intended to be read by another computer that has a different endianness than the one you are operating on. There are times when you need to know if you should swap your compound integer types to a different endianness or not.
        * 
        * @note
        *   The first time either of these functions are called they will be slightly inefficient, however any sucessive calls will be lightning fast.
        */

            // Is_Big()
            /**
            * @class _9d5ef4e6_ff8f_4d63_9fdc_0c0422259d90
            * @private
            */

            // Is_Little()
            /**
            * @class _884ae9eb_da64_4306_aab9_50aeb3f85298
            * @private
            */

        // Swap
        /**
        * @class _b5b179fb_1f64_485e_9510_80260e3a6c33
        * @private
        *
        * @brief
        *   Invert the order of bytes in a multi-byte number.
        * 
        * @details
        *   These are useful when you are dealing with data that was either written by or will be read by a processor that has a different endianness than the one your program is executing on.
        *
        * @note
        *   There is no nkr::integer_8_tr variant because a byte or a stream of bytes cannot have a different endianness but is read and written the same on both kinds of computers.
        */

            // Swap(integer_16_tr)
            /**
            * @class _857ce8b6_02ca_48e5_9d19_4a7581b8e4c6
            * @private
            */

            // Swap(integer_32_tr)
            /**
            * @class _02c0499c_c8c8_43b9_8afc_96545310eb3a
            * @private
            */

            // Swap(integer_64_tr)
            /**
            * @class _eabf9a88_080f_445d_88ab_b0dae4a55316
            * @private
            */

    // nkr::os::heap
    /**
    * @class _a6c4699b_8fe4_4664_ac57_062765decc2b
    * @private
    *
    * @brief
    *   Functions that interface with memory located on the heap.
    */

        // Allocation
        /**
        * @class _30c0ffe4_d85f_45e5_ab29_bd3f18629cb9
        * @private
        *
        * @brief
        *   Borrow a certain amount of memory from the heap. Use it, expand it, and give it back.
        */

            // Allocate()
            /**
            * @class _52a0d839_49c8_4d77_93b1_353137fecd3b
            * @private
            *
            * @brief
            *   Gives you memory to use until you deallocate it or your program exits.
            * 
            * @param units
            *   is the pointer that may be set to point to the allocated memory.
            * 
            * @param unit_count
            *   is the number of units (type instances) that will be allocated. It must be greater than zero.
            *
            * @returns
            *   `true` if it succeeds, setting units to the allocated pointer.
            * 
            * @returns
            *   `false` if it fails, setting units to `nullptr`.
            * 
            * @details
            *   There are a few limitations to the number of bytes you can allocate depending on:
            * 
            *   1. how much ram is physically in the computer
            *   2. how much space the operating system has left to give
            *   3. the settings that your compiler operates with
            *   4. what the natural word size of the processor is
            * 
            *   At most the largest number of bytes you will be able to allocate is the max number that can fit in an nkr::count_t (an alias of nkr::word_t). If you are running on a 32 bit processor you will only be able to allocate one byte shy of 4gb, which is no where near the amount of memory you can allocate on a 64 bit processor. Furthermore, limitations may come into play depending on the operating system, which may significantly decrease that amount even further.
            */

            // Reallocate()
            /**
            * @class _06fa627b_ba42_4b70_b0dd_66146e6d863a
            * @private
            *
            * @brief
            *   Gives you more memory while keeping all your data intact.
            *
            * @param units
            *   should be a pointer set by nkr::os::heap::Allocate or nkr::os::heap::Reallocate. When successful, it will be set to a new pointer if necessary, or else it will be left unchanged.
            *
            * @param new_unit_count
            *   is the total number of units (type instances) that may be allocated after this function returns. It should be the total size you want the memory to be. It must be greater than zero.
            *
            * @returns
            *   `true` if it succeeds, setting units to a different allocated pointer if necessary, else leaving it alone.
            *
            * @returns
            *   `false` when it fails, leaving units alone.
            *
            * @details
            *   This will allocate more memory for you if the new count is greater than the currently allocated count. Otherwise, it will simply return as if it had succeeded, with no changes to the pointer. See nkr::os::heap::Allocate for more details about allocation generally.
            *
            * @note
            *   This cannot shrink the memory you allocate, but some higher level types in the library may by request.
            *
            * @todo
            *   Maybe return an enum_t to indicate different kinds of failures, at least on Windows?
            */

            // Deallocate()
            /**
            * @class _de0237bf_9b0a_47fc_a5ab_99f21504f570
            * @private
            *
            * @brief
            *   Takes back memory you no longer need so it can be reused later.
            *
            * @param units
            *   should be a pointer set by nkr::os::heap::Allocate or nkr::os::heap::Reallocate. It will be set to `nullptr` after deallocation. If it is already `nullptr`, the function returns as if it was already successful.
            *
            * @details
            *   When using these functions, memory will never be deallocated automatically for you like it is in some higher level types. You will have to manually deallocate every pointer you allocate, or else you may unexpectedly run out of memory. Regardless, the operating system will deallocate everything that has not already been deallocated when your program exits.
            */

        // Zero-Initialized Allocation
        /**
        * @class _eca47636_431b_4d2a_a102_679075b3cf17
        * @private
        *
        * @brief
        *   A variant of regular allocation, all the values in your memory will be initialized to zero.
        */

            // Allocate_Zeros()
            /**
            * @class _9c5a7296_5644_47bf_bd3f_ff7de3518ce9
            * @private
            *
            * @brief
            *   Gives you zero-initialized memory to use until your program exits.
            *
            * @param units
            *   is the pointer that may be set to point to the allocated memory.
            * 
            * @param unit_count
            *   is the number of units (type instances) that will be allocated. It must be greater than zero.
            *
            * @returns
            *   `true` if it succeeds, setting units to the allocated pointer.
            * 
            * @returns
            *   `false` if it fails, setting units to `nullptr`.
            *
            * @details
            *   This uses an efficient operating system dependent algorithm to avoid zeroing out all values during runtime. Normally the os will keep pages of zero initialized bytes ready for allocation and it will only need to initialize them on the occasion that it doesn't have any of those pages readily available. Please see nkr::os::heap::Allocate for more details.
            *
            * @note
            *   The returned pointer can be used with nkr::os::heap::Reallocate to allocate more memory but without it being zero-intialized, and nkr::os::heap::Deallocate to free the memory. Both of these are currently frowned upon because they may not work in future updates or on certain operating systems.
            */

            // Reallocate_Zeros()
            /**
            * @class _7d7887a0_3e2d_4502_af8c_d409aae73f0b
            * @private
            * 
            * @brief
            *   Gives you more zero-initialized memory while keeping all your data intact.
            *
            * @param units
            *   should be a pointer set by nkr::os::heap::Allocate_Zeros or nkr::os::heap::Reallocate_Zeros. When successful, it will be set to a new pointer if necessary, or else it will be left unchanged.
            *
            * @param new_unit_count
            *   is the total number of units (type instances) that may be allocated after this function returns. It should be the total size you want the memory to be. It must be greater than zero.
            *
            * @returns
            *   `true` if it succeeds, setting units to a different allocated pointer if necessary, else leaving it alone.
            *
            * @returns
            *   `false` when it fails, leaving units alone.
            *
            * @details
            *   Please see nkr::os::heap::Reallocate for more details.
            */

            // Deallocate_Zeros()
            /**
            * @class _04d9a3fe_30b3_4ae2_bbc4_2a3cfc4768d6
            * @private
            * 
            * @brief
            *   Takes back memory you no longer need so it can be reused later.
            *
            * @param units
            *   should be a pointer set by nkr::os::heap::Allocate_Zeros or nkr::os::heap::Reallocate_Zeros. It will be set to `nullptr` after deallocation. If it is already `nullptr`, the function returns as if it was already successful.
            *
            * @details
            *   Please see nkr::os::heap::Deallocate for more details.
            *
            * @note
            *   This does not zero the memory.
            */
